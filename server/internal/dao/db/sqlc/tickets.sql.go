// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: tickets.sql

package db

import (
	"context"
	"time"
)

const createTicket = `-- name: CreateTicket :exec
insert into ttms.public."tickets"
    (plan_id, seats_id, price)
values ($1, $2, $3)
`

type CreateTicketParams struct {
	Planid int64   `json:"planid"`
	Seatid int64   `json:"seatid"`
	Price  float32 `json:"price"`
}

func (q *Queries) CreateTicket(ctx context.Context, arg *CreateTicketParams) error {
	_, err := q.db.Exec(ctx, createTicket, arg.Planid, arg.Seatid, arg.Price)
	return err
}

type CreateTicketsParams struct {
	PlanID  int64   `json:"plan_id"`
	SeatsID int64   `json:"seats_id"`
	Price   float32 `json:"price"`
}

const deleteByPlan = `-- name: DeleteByPlan :exec
delete
from ttms.public."tickets"
where plan_id = $1
`

func (q *Queries) DeleteByPlan(ctx context.Context, planid int64) error {
	_, err := q.db.Exec(ctx, deleteByPlan, planid)
	return err
}

const deleteBySeats = `-- name: DeleteBySeats :exec
delete
from ttms.public."tickets"
where seats_id = $1
  and plan_id = $2
`

type DeleteBySeatsParams struct {
	Seatid int64 `json:"seatid"`
	Planid int64 `json:"planid"`
}

func (q *Queries) DeleteBySeats(ctx context.Context, arg *DeleteBySeatsParams) error {
	_, err := q.db.Exec(ctx, deleteBySeats, arg.Seatid, arg.Planid)
	return err
}

const existSoldTicketsByPlan = `-- name: ExistSoldTicketsByPlan :one
select exists(select 1
              from tickets,
                   plan
              where tickets.plan_id = $1
                and plan.id = tickets.plan_id
                and (tickets.status = '已售'
                  or tickets.status = '锁定')
                and plan.end_at > now())
`

// 查询演出计划是否有已经售出或者锁定的票
func (q *Queries) ExistSoldTicketsByPlan(ctx context.Context, planid int64) (bool, error) {
	row := q.db.QueryRow(ctx, existSoldTicketsByPlan, planid)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllTickets = `-- name: GetAllTickets :many
select user_id, plan_id, seats_id, price, status, lock_time
from ttms.public."tickets"
order by plan_id desc
limit $1 offset $2
`

type GetAllTicketsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllTicketsRow struct {
	UserID   int64        `json:"user_id"`
	PlanID   int64        `json:"plan_id"`
	SeatsID  int64        `json:"seats_id"`
	Price    float32      `json:"price"`
	Status   Ticketstatus `json:"status"`
	LockTime time.Time    `json:"lock_time"`
}

func (q *Queries) GetAllTickets(ctx context.Context, arg *GetAllTicketsParams) ([]*GetAllTicketsRow, error) {
	rows, err := q.db.Query(ctx, getAllTickets, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllTicketsRow{}
	for rows.Next() {
		var i GetAllTicketsRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.Price,
			&i.Status,
			&i.LockTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getByPlan = `-- name: GetByPlan :many
select user_id, plan_id, seats_id, price, status, lock_time
from ttms.public."tickets"
where plan_id = $1
`

type GetByPlanRow struct {
	UserID   int64        `json:"user_id"`
	PlanID   int64        `json:"plan_id"`
	SeatsID  int64        `json:"seats_id"`
	Price    float32      `json:"price"`
	Status   Ticketstatus `json:"status"`
	LockTime time.Time    `json:"lock_time"`
}

func (q *Queries) GetByPlan(ctx context.Context, planid int64) ([]*GetByPlanRow, error) {
	rows, err := q.db.Query(ctx, getByPlan, planid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetByPlanRow{}
	for rows.Next() {
		var i GetByPlanRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.Price,
			&i.Status,
			&i.LockTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicket = `-- name: GetTicket :one
select user_id, plan_id, seats_id, price, status, lock_time
from ttms.public."tickets"
where plan_id = $1
  and seats_id = $2
`

type GetTicketParams struct {
	Planid int64 `json:"planid"`
	Seatid int64 `json:"seatid"`
}

type GetTicketRow struct {
	UserID   int64        `json:"user_id"`
	PlanID   int64        `json:"plan_id"`
	SeatsID  int64        `json:"seats_id"`
	Price    float32      `json:"price"`
	Status   Ticketstatus `json:"status"`
	LockTime time.Time    `json:"lock_time"`
}

func (q *Queries) GetTicket(ctx context.Context, arg *GetTicketParams) (*GetTicketRow, error) {
	row := q.db.QueryRow(ctx, getTicket, arg.Planid, arg.Seatid)
	var i GetTicketRow
	err := row.Scan(
		&i.UserID,
		&i.PlanID,
		&i.SeatsID,
		&i.Price,
		&i.Status,
		&i.LockTime,
	)
	return &i, err
}

const getTicketNum = `-- name: GetTicketNum :one
select count(*)
from ttms.public."tickets"
`

func (q *Queries) GetTicketNum(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTicketNum)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getTicketsByPlan = `-- name: GetTicketsByPlan :many
select t.plan_id, t.seats_id, s.status, t.price, t.status, s.row, s.col
from ttms.public.seats s,
     ttms.public.tickets t
where t.plan_id = $1
  and t.seats_id = s.id
`

type GetTicketsByPlanRow struct {
	PlanID   int64        `json:"plan_id"`
	SeatsID  int64        `json:"seats_id"`
	Status   Seatsstatus  `json:"status"`
	Price    float32      `json:"price"`
	Status_2 Ticketstatus `json:"status_2"`
	Row      int16        `json:"row"`
	Col      int16        `json:"col"`
}

func (q *Queries) GetTicketsByPlan(ctx context.Context, planID int64) ([]*GetTicketsByPlanRow, error) {
	rows, err := q.db.Query(ctx, getTicketsByPlan, planID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTicketsByPlanRow{}
	for rows.Next() {
		var i GetTicketsByPlanRow
		if err := rows.Scan(
			&i.PlanID,
			&i.SeatsID,
			&i.Status,
			&i.Price,
			&i.Status_2,
			&i.Row,
			&i.Col,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTicketsLocked = `-- name: GetTicketsLocked :many
select user_id, plan_id, seats_id, price, status, lock_time
from ttms.public."tickets"
where plan_id = $1
  and status = '锁定'
`

type GetTicketsLockedRow struct {
	UserID   int64        `json:"user_id"`
	PlanID   int64        `json:"plan_id"`
	SeatsID  int64        `json:"seats_id"`
	Price    float32      `json:"price"`
	Status   Ticketstatus `json:"status"`
	LockTime time.Time    `json:"lock_time"`
}

func (q *Queries) GetTicketsLocked(ctx context.Context, planid int64) ([]*GetTicketsLockedRow, error) {
	rows, err := q.db.Query(ctx, getTicketsLocked, planid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetTicketsLockedRow{}
	for rows.Next() {
		var i GetTicketsLockedRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.Price,
			&i.Status,
			&i.LockTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockTicket = `-- name: LockTicket :exec
update ttms.public.tickets
set status  = $1,
    user_id = $2
where plan_id = $3
  and seats_id = $4
`

type LockTicketParams struct {
	Status  Ticketstatus `json:"status"`
	UserID  int64        `json:"user_id"`
	PlanID  int64        `json:"plan_id"`
	SeatsID int64        `json:"seats_id"`
}

func (q *Queries) LockTicket(ctx context.Context, arg *LockTicketParams) error {
	_, err := q.db.Exec(ctx, lockTicket,
		arg.Status,
		arg.UserID,
		arg.PlanID,
		arg.SeatsID,
	)
	return err
}

const payTicket = `-- name: PayTicket :exec
update ttms.public.tickets
set status  = $1,
    user_id = $2
where plan_id = $3
  and seats_id = $4
`

type PayTicketParams struct {
	Status  Ticketstatus `json:"status"`
	UserID  int64        `json:"user_id"`
	PlanID  int64        `json:"plan_id"`
	SeatsID int64        `json:"seats_id"`
}

func (q *Queries) PayTicket(ctx context.Context, arg *PayTicketParams) error {
	_, err := q.db.Exec(ctx, payTicket,
		arg.Status,
		arg.UserID,
		arg.PlanID,
		arg.SeatsID,
	)
	return err
}

const queryCountTicketPlan = `-- name: QueryCountTicketPlan :one
select count(*)
from ttms.public.tickets
where plan_id = $1
`

func (q *Queries) QueryCountTicketPlan(ctx context.Context, planID int64) (int64, error) {
	row := q.db.QueryRow(ctx, queryCountTicketPlan, planID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const searchTicketByPlanId = `-- name: SearchTicketByPlanId :many
select user_id, plan_id, seats_id, price, status, lock_time
from ttms.public.tickets
where plan_id = $1
order by plan_id desc
limit $2 offset $3
`

type SearchTicketByPlanIdParams struct {
	PlanID int64 `json:"plan_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type SearchTicketByPlanIdRow struct {
	UserID   int64        `json:"user_id"`
	PlanID   int64        `json:"plan_id"`
	SeatsID  int64        `json:"seats_id"`
	Price    float32      `json:"price"`
	Status   Ticketstatus `json:"status"`
	LockTime time.Time    `json:"lock_time"`
}

func (q *Queries) SearchTicketByPlanId(ctx context.Context, arg *SearchTicketByPlanIdParams) ([]*SearchTicketByPlanIdRow, error) {
	rows, err := q.db.Query(ctx, searchTicketByPlanId, arg.PlanID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchTicketByPlanIdRow{}
	for rows.Next() {
		var i SearchTicketByPlanIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.Price,
			&i.Status,
			&i.LockTime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unLockTicket = `-- name: UnLockTicket :exec
update ttms.public.tickets
set status = '正常'
where plan_id = $1
  and user_id = $2
  and seats_id = $3
`

type UnLockTicketParams struct {
	PlanID  int64 `json:"plan_id"`
	UserID  int64 `json:"user_id"`
	SeatsID int64 `json:"seats_id"`
}

func (q *Queries) UnLockTicket(ctx context.Context, arg *UnLockTicketParams) error {
	_, err := q.db.Exec(ctx, unLockTicket, arg.PlanID, arg.UserID, arg.SeatsID)
	return err
}
