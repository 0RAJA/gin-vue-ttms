// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: cinema.sql

package db

import (
	"context"
)

const checkCinemaByName = `-- name: CheckCinemaByName :one
select exists(
               select 1
               from cinema
               where name = $1
           )
`

func (q *Queries) CheckCinemaByName(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRow(ctx, checkCinemaByName, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createCinema = `-- name: CreateCinema :one
insert into cinema (name, avatar, rows, cols)
values ($1, $2, $3, $4)
returning id, name, avatar, rows, cols
`

type CreateCinemaParams struct {
	Name   string `json:"name"`
	Avatar string `json:"avatar"`
	Rows   int16  `json:"rows"`
	Cols   int16  `json:"cols"`
}

func (q *Queries) CreateCinema(ctx context.Context, arg *CreateCinemaParams) (*Cinema, error) {
	row := q.db.QueryRow(ctx, createCinema,
		arg.Name,
		arg.Avatar,
		arg.Rows,
		arg.Cols,
	)
	var i Cinema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.Rows,
		&i.Cols,
	)
	return &i, err
}

const deleteCinemaByID = `-- name: DeleteCinemaByID :exec
delete
from cinema
where id = $1
`

func (q *Queries) DeleteCinemaByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteCinemaByID, id)
	return err
}

const getCinemaByID = `-- name: GetCinemaByID :one
select id, name, avatar, rows, cols
from cinema
where id = $1
limit 1
`

func (q *Queries) GetCinemaByID(ctx context.Context, id int64) (*Cinema, error) {
	row := q.db.QueryRow(ctx, getCinemaByID, id)
	var i Cinema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.Rows,
		&i.Cols,
	)
	return &i, err
}

const getCinemaByPlanID = `-- name: GetCinemaByPlanID :one
select cinema.id, cinema.name, cinema.avatar, cinema.rows, cinema.cols
from plan,
     cinema
where plan.id = $1
  and plan.cinema_id = cinema.id
  and plan.end_at > now()
limit 1
`

func (q *Queries) GetCinemaByPlanID(ctx context.Context, id int64) (*Cinema, error) {
	row := q.db.QueryRow(ctx, getCinemaByPlanID, id)
	var i Cinema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.Rows,
		&i.Cols,
	)
	return &i, err
}

const getCinemas = `-- name: GetCinemas :many
select id, name, avatar, rows, cols, count(*) over () as total
from cinema
order by id desc
limit $1 offset $2
`

type GetCinemasParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetCinemasRow struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Avatar string `json:"avatar"`
	Rows   int16  `json:"rows"`
	Cols   int16  `json:"cols"`
	Total  int64  `json:"total"`
}

func (q *Queries) GetCinemas(ctx context.Context, arg *GetCinemasParams) ([]*GetCinemasRow, error) {
	rows, err := q.db.Query(ctx, getCinemas, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetCinemasRow{}
	for rows.Next() {
		var i GetCinemasRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Avatar,
			&i.Rows,
			&i.Cols,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrderInfoByCinemaId = `-- name: GetOrderInfoByCinemaId :one
select  m.avatar,m.name,c.name
from ttms.public.movie m ,
     ttms.public.cinema c
where m.id = $1
and c.id = $2
`

type GetOrderInfoByCinemaIdParams struct {
	MovieID  int64 `json:"movie_id"`
	CinemaID int64 `json:"cinema_id"`
}

type GetOrderInfoByCinemaIdRow struct {
	Avatar string `json:"avatar"`
	Name   string `json:"name"`
	Name_2 string `json:"name_2"`
}

func (q *Queries) GetOrderInfoByCinemaId(ctx context.Context, arg *GetOrderInfoByCinemaIdParams) (*GetOrderInfoByCinemaIdRow, error) {
	row := q.db.QueryRow(ctx, getOrderInfoByCinemaId, arg.MovieID, arg.CinemaID)
	var i GetOrderInfoByCinemaIdRow
	err := row.Scan(&i.Avatar, &i.Name, &i.Name_2)
	return &i, err
}

const updateCinema = `-- name: UpdateCinema :one
update cinema
set name   = $2,
    avatar = $3
where id = $1
returning id, name, avatar, rows, cols
`

type UpdateCinemaParams struct {
	ID     int64  `json:"id"`
	Name   string `json:"name"`
	Avatar string `json:"avatar"`
}

func (q *Queries) UpdateCinema(ctx context.Context, arg *UpdateCinemaParams) (*Cinema, error) {
	row := q.db.QueryRow(ctx, updateCinema, arg.ID, arg.Name, arg.Avatar)
	var i Cinema
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Avatar,
		&i.Rows,
		&i.Cols,
	)
	return &i, err
}
