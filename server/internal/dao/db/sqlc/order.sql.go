// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: order.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createOrder = `-- name: CreateOrder :exec
insert into ttms.public."order"(user_id, order_id, movie_name, movie_avatar, cinema_name, create_at, seats, price, status,plan_id,seats_id)
values ($1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11)
`

type CreateOrderParams struct {
	UserID      int64       `json:"user_id"`
	OrderID     uuid.UUID   `json:"order_id"`
	MovieName   string      `json:"movie_name"`
	MovieAvatar string      `json:"movie_avatar"`
	CinemaName  string      `json:"cinema_name"`
	CreateAt    time.Time   `json:"create_at"`
	Seats       string      `json:"seats"`
	Price       float32     `json:"price"`
	Status      Orderstatus `json:"status"`
	PlanID      int64       `json:"plan_id"`
	SeatsID     string      `json:"seats_id"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg *CreateOrderParams) error {
	_, err := q.db.Exec(ctx, createOrder,
		arg.UserID,
		arg.OrderID,
		arg.MovieName,
		arg.MovieAvatar,
		arg.CinemaName,
		arg.CreateAt,
		arg.Seats,
		arg.Price,
		arg.Status,
		arg.PlanID,
		arg.SeatsID,
	)
	return err
}

const deleteOrderByTicket = `-- name: DeleteOrderByTicket :exec
delete
from ttms.public."order"
where plan_id = $1
and seats_id = $2
`

type DeleteOrderByTicketParams struct {
	PlanID  int64  `json:"plan_id"`
	SeatsID string `json:"seats_id"`
}

func (q *Queries) DeleteOrderByTicket(ctx context.Context, arg *DeleteOrderByTicketParams) error {
	_, err := q.db.Exec(ctx, deleteOrderByTicket, arg.PlanID, arg.SeatsID)
	return err
}

const deleteOrderByUUID = `-- name: DeleteOrderByUUID :exec
delete from ttms.public."order"
where order_id = $1
`

func (q *Queries) DeleteOrderByUUID(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteOrderByUUID, orderID)
	return err
}

const getNumsAll = `-- name: GetNumsAll :one
select count(*) from
ttms.public."order"
`

func (q *Queries) GetNumsAll(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getNumsAll)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getOrderByUserId = `-- name: GetOrderByUserId :many
select user_id, plan_id, seats_id, order_id, movie_name, movie_avatar, cinema_name, create_at, seats, price, status from
ttms.public."order"
where user_id = $1
`

type GetOrderByUserIdRow struct {
	UserID      int64       `json:"user_id"`
	PlanID      int64       `json:"plan_id"`
	SeatsID     string      `json:"seats_id"`
	OrderID     uuid.UUID   `json:"order_id"`
	MovieName   string      `json:"movie_name"`
	MovieAvatar string      `json:"movie_avatar"`
	CinemaName  string      `json:"cinema_name"`
	CreateAt    time.Time   `json:"create_at"`
	Seats       string      `json:"seats"`
	Price       float32     `json:"price"`
	Status      Orderstatus `json:"status"`
}

func (q *Queries) GetOrderByUserId(ctx context.Context, userID int64) ([]*GetOrderByUserIdRow, error) {
	rows, err := q.db.Query(ctx, getOrderByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetOrderByUserIdRow{}
	for rows.Next() {
		var i GetOrderByUserIdRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.OrderID,
			&i.MovieName,
			&i.MovieAvatar,
			&i.CinemaName,
			&i.CreateAt,
			&i.Seats,
			&i.Price,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWaitPayOrder = `-- name: GetWaitPayOrder :many
select user_id, plan_id, seats_id, order_id, movie_name, movie_avatar, cinema_name, create_at, seats, price, status from
ttms.public."order"
where status = '待支付'
`

type GetWaitPayOrderRow struct {
	UserID      int64       `json:"user_id"`
	PlanID      int64       `json:"plan_id"`
	SeatsID     string      `json:"seats_id"`
	OrderID     uuid.UUID   `json:"order_id"`
	MovieName   string      `json:"movie_name"`
	MovieAvatar string      `json:"movie_avatar"`
	CinemaName  string      `json:"cinema_name"`
	CreateAt    time.Time   `json:"create_at"`
	Seats       string      `json:"seats"`
	Price       float32     `json:"price"`
	Status      Orderstatus `json:"status"`
}

func (q *Queries) GetWaitPayOrder(ctx context.Context) ([]*GetWaitPayOrderRow, error) {
	rows, err := q.db.Query(ctx, getWaitPayOrder)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetWaitPayOrderRow{}
	for rows.Next() {
		var i GetWaitPayOrderRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.OrderID,
			&i.MovieName,
			&i.MovieAvatar,
			&i.CinemaName,
			&i.CreateAt,
			&i.Seats,
			&i.Price,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchAllOrder = `-- name: SearchAllOrder :many
select user_id, plan_id, seats_id, order_id, movie_name, movie_avatar, cinema_name, create_at, seats, price, status from
ttms.public."order"
order by user_id desc
limit $1 offset $2
`

type SearchAllOrderParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type SearchAllOrderRow struct {
	UserID      int64       `json:"user_id"`
	PlanID      int64       `json:"plan_id"`
	SeatsID     string      `json:"seats_id"`
	OrderID     uuid.UUID   `json:"order_id"`
	MovieName   string      `json:"movie_name"`
	MovieAvatar string      `json:"movie_avatar"`
	CinemaName  string      `json:"cinema_name"`
	CreateAt    time.Time   `json:"create_at"`
	Seats       string      `json:"seats"`
	Price       float32     `json:"price"`
	Status      Orderstatus `json:"status"`
}

func (q *Queries) SearchAllOrder(ctx context.Context, arg *SearchAllOrderParams) ([]*SearchAllOrderRow, error) {
	rows, err := q.db.Query(ctx, searchAllOrder, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchAllOrderRow{}
	for rows.Next() {
		var i SearchAllOrderRow
		if err := rows.Scan(
			&i.UserID,
			&i.PlanID,
			&i.SeatsID,
			&i.OrderID,
			&i.MovieName,
			&i.MovieAvatar,
			&i.CinemaName,
			&i.CreateAt,
			&i.Seats,
			&i.Price,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrderByCondition = `-- name: SearchOrderByCondition :many
select order_id,user_id,movie_name, movie_avatar, cinema_name, create_at, seats, price, status,plan_id,seats_id,count(*) over () as total
from ttms.public."order"
where movie_name like $1
   or cinema_name like $1
order by user_id desc
limit $2 offset $3
`

type SearchOrderByConditionParams struct {
	MovieName string `json:"movie_name"`
	Limit     int32  `json:"limit"`
	Offset    int32  `json:"offset"`
}

type SearchOrderByConditionRow struct {
	OrderID     uuid.UUID   `json:"order_id"`
	UserID      int64       `json:"user_id"`
	MovieName   string      `json:"movie_name"`
	MovieAvatar string      `json:"movie_avatar"`
	CinemaName  string      `json:"cinema_name"`
	CreateAt    time.Time   `json:"create_at"`
	Seats       string      `json:"seats"`
	Price       float32     `json:"price"`
	Status      Orderstatus `json:"status"`
	PlanID      int64       `json:"plan_id"`
	SeatsID     string      `json:"seats_id"`
	Total       int64       `json:"total"`
}

func (q *Queries) SearchOrderByCondition(ctx context.Context, arg *SearchOrderByConditionParams) ([]*SearchOrderByConditionRow, error) {
	rows, err := q.db.Query(ctx, searchOrderByCondition, arg.MovieName, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchOrderByConditionRow{}
	for rows.Next() {
		var i SearchOrderByConditionRow
		if err := rows.Scan(
			&i.OrderID,
			&i.UserID,
			&i.MovieName,
			&i.MovieAvatar,
			&i.CinemaName,
			&i.CreateAt,
			&i.Seats,
			&i.Price,
			&i.Status,
			&i.PlanID,
			&i.SeatsID,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOrderStatus = `-- name: UpdateOrderStatus :exec
update ttms.public."order"
set
status = '已支付'
where order_id = $1
`

func (q *Queries) UpdateOrderStatus(ctx context.Context, orderID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateOrderStatus, orderID)
	return err
}
