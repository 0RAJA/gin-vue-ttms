// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: movie.sql

package db

import (
	"context"
	"time"
)

const addMovieBoxOffice = `-- name: AddMovieBoxOffice :exec
update movie
set box_office = box_office + $2
where id = $1
`

type AddMovieBoxOfficeParams struct {
	ID        int64   `json:"id"`
	BoxOffice float32 `json:"box_office"`
}

func (q *Queries) AddMovieBoxOffice(ctx context.Context, arg *AddMovieBoxOfficeParams) error {
	_, err := q.db.Exec(ctx, addMovieBoxOffice, arg.ID, arg.BoxOffice)
	return err
}

const addMovieVisitCount = `-- name: AddMovieVisitCount :exec
update movie
set visit_count = visit_count + $2
where id = $1
`

type AddMovieVisitCountParams struct {
	ID         int64 `json:"id"`
	VisitCount int64 `json:"visit_count"`
}

func (q *Queries) AddMovieVisitCount(ctx context.Context, arg *AddMovieVisitCountParams) error {
	_, err := q.db.Exec(ctx, addMovieVisitCount, arg.ID, arg.VisitCount)
	return err
}

const createMovie = `-- name: CreateMovie :one
insert into movie (name, director, alias_name, actors, content, avatar, duration, area, period)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
returning id,name,director, alias_name, actors, content, avatar, duration, area, period
`

type CreateMovieParams struct {
	Name      string    `json:"name"`
	Director  string    `json:"director"`
	AliasName string    `json:"alias_name"`
	Actors    []string  `json:"actors"`
	Content   string    `json:"content"`
	Avatar    string    `json:"avatar"`
	Duration  int16     `json:"duration"`
	Area      string    `json:"area"`
	Period    time.Time `json:"period"`
}

type CreateMovieRow struct {
	ID        int64     `json:"id"`
	Name      string    `json:"name"`
	Director  string    `json:"director"`
	AliasName string    `json:"alias_name"`
	Actors    []string  `json:"actors"`
	Content   string    `json:"content"`
	Avatar    string    `json:"avatar"`
	Duration  int16     `json:"duration"`
	Area      string    `json:"area"`
	Period    time.Time `json:"period"`
}

func (q *Queries) CreateMovie(ctx context.Context, arg *CreateMovieParams) (*CreateMovieRow, error) {
	row := q.db.QueryRow(ctx, createMovie,
		arg.Name,
		arg.Director,
		arg.AliasName,
		arg.Actors,
		arg.Content,
		arg.Avatar,
		arg.Duration,
		arg.Area,
		arg.Period,
	)
	var i CreateMovieRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Director,
		&i.AliasName,
		&i.Actors,
		&i.Content,
		&i.Avatar,
		&i.Duration,
		&i.Area,
		&i.Period,
	)
	return &i, err
}

const deleteMovieByID = `-- name: DeleteMovieByID :exec
delete
from movie
where id = $1
`

func (q *Queries) DeleteMovieByID(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteMovieByID, id)
	return err
}

const getAreas = `-- name: GetAreas :many
select distinct area
from movie
order by area
limit $1 offset $2
`

type GetAreasParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) GetAreas(ctx context.Context, arg *GetAreasParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getAreas, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var area string
		if err := rows.Scan(&area); err != nil {
			return nil, err
		}
		items = append(items, area)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMovieByID = `-- name: GetMovieByID :one
select movie.id,
       name,
       director,
       movie.alias_name,
       actors,
       movie.content,
       avatar,
       visit_count,
       box_office,
       duration,
       period,
       movie.score,
       area,
       (select count(*)
        from comment
        where comment.movie_id = $1)          as comment_count,
       (select count(*)
        from user_movie
        where user_movie.movie_id = movie.id) as follow_count
from movie
where id = $1
limit 1
`

type GetMovieByIDRow struct {
	ID           int64     `json:"id"`
	Name         string    `json:"name"`
	Director     string    `json:"director"`
	AliasName    string    `json:"alias_name"`
	Actors       []string  `json:"actors"`
	Content      string    `json:"content"`
	Avatar       string    `json:"avatar"`
	VisitCount   int64     `json:"visit_count"`
	BoxOffice    float32   `json:"box_office"`
	Duration     int16     `json:"duration"`
	Period       time.Time `json:"period"`
	Score        float32   `json:"score"`
	Area         string    `json:"area"`
	CommentCount int64     `json:"comment_count"`
	FollowCount  int64     `json:"follow_count"`
}

func (q *Queries) GetMovieByID(ctx context.Context, movieID int64) (*GetMovieByIDRow, error) {
	row := q.db.QueryRow(ctx, getMovieByID, movieID)
	var i GetMovieByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Director,
		&i.AliasName,
		&i.Actors,
		&i.Content,
		&i.Avatar,
		&i.VisitCount,
		&i.BoxOffice,
		&i.Duration,
		&i.Period,
		&i.Score,
		&i.Area,
		&i.CommentCount,
		&i.FollowCount,
	)
	return &i, err
}

const getMovies = `-- name: GetMovies :many
select id,
       name,
       director,
       alias_name,
       actors,
       content,
       avatar,
       duration,
       area,
       period,
       count(*) over () as total
from movie
order by id desc
limit $1 offset $2
`

type GetMoviesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMoviesRow struct {
	ID        int64     `json:"id"`
	Name      string    `json:"name"`
	Director  string    `json:"director"`
	AliasName string    `json:"alias_name"`
	Actors    []string  `json:"actors"`
	Content   string    `json:"content"`
	Avatar    string    `json:"avatar"`
	Duration  int16     `json:"duration"`
	Area      string    `json:"area"`
	Period    time.Time `json:"period"`
	Total     int64     `json:"total"`
}

func (q *Queries) GetMovies(ctx context.Context, arg *GetMoviesParams) ([]*GetMoviesRow, error) {
	rows, err := q.db.Query(ctx, getMovies, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesRow{}
	for rows.Next() {
		var i GetMoviesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Director,
			&i.AliasName,
			&i.Actors,
			&i.Content,
			&i.Avatar,
			&i.Duration,
			&i.Area,
			&i.Period,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesByIDs = `-- name: GetMoviesByIDs :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score
from movie
where id = any ($1::bigint[])
order by array_positions($1::bigint[], id::bigint)
`

type GetMoviesByIDsRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
}

func (q *Queries) GetMoviesByIDs(ctx context.Context, ids []int64) ([]*GetMoviesByIDsRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByIDs, ids)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesByIDsRow{}
	for rows.Next() {
		var i GetMoviesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesByNameOrContent = `-- name: GetMoviesByNameOrContent :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       count(*) over () as total
from movie
where movie.name = $3
   or movie.alias_name = $3
   or movie.name_content_alias_tsv @@ plainto_tsquery($3::varchar)
limit $1 offset $2
`

type GetMoviesByNameOrContentParams struct {
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
	Key    string `json:"key"`
}

type GetMoviesByNameOrContentRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
	Total     int64     `json:"total"`
}

func (q *Queries) GetMoviesByNameOrContent(ctx context.Context, arg *GetMoviesByNameOrContentParams) ([]*GetMoviesByNameOrContentRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByNameOrContent, arg.Limit, arg.Offset, arg.Key)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesByNameOrContentRow{}
	for rows.Next() {
		var i GetMoviesByNameOrContentRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesByTagPeriodAreaOrderByPeriod = `-- name: GetMoviesByTagPeriodAreaOrderByPeriod :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       count(*) over () as total
from movie,
     (select distinct movie_id from tags where tags.tag_name like $2) as tags
where period between $5 and $6
  and area like $1
  and id = tags.movie_id
order by period desc
limit $3 offset $4
`

type GetMoviesByTagPeriodAreaOrderByPeriodParams struct {
	Area      string    `json:"area"`
	TagName   string    `json:"tag_name"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
	Starttime time.Time `json:"starttime"`
	Endtime   time.Time `json:"endtime"`
}

type GetMoviesByTagPeriodAreaOrderByPeriodRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
	Total     int64     `json:"total"`
}

func (q *Queries) GetMoviesByTagPeriodAreaOrderByPeriod(ctx context.Context, arg *GetMoviesByTagPeriodAreaOrderByPeriodParams) ([]*GetMoviesByTagPeriodAreaOrderByPeriodRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByTagPeriodAreaOrderByPeriod,
		arg.Area,
		arg.TagName,
		arg.Limit,
		arg.Offset,
		arg.Starttime,
		arg.Endtime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesByTagPeriodAreaOrderByPeriodRow{}
	for rows.Next() {
		var i GetMoviesByTagPeriodAreaOrderByPeriodRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesByTagPeriodAreaOrderByScore = `-- name: GetMoviesByTagPeriodAreaOrderByScore :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       count(*) over () as total
from movie,
     (select distinct movie_id from tags where tags.tag_name like $2) as tags
where period between $5 and $6
  and area like $1
  and id = tags.movie_id
order by score desc
limit $3 offset $4
`

type GetMoviesByTagPeriodAreaOrderByScoreParams struct {
	Area      string    `json:"area"`
	TagName   string    `json:"tag_name"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
	Starttime time.Time `json:"starttime"`
	Endtime   time.Time `json:"endtime"`
}

type GetMoviesByTagPeriodAreaOrderByScoreRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
	Total     int64     `json:"total"`
}

func (q *Queries) GetMoviesByTagPeriodAreaOrderByScore(ctx context.Context, arg *GetMoviesByTagPeriodAreaOrderByScoreParams) ([]*GetMoviesByTagPeriodAreaOrderByScoreRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByTagPeriodAreaOrderByScore,
		arg.Area,
		arg.TagName,
		arg.Limit,
		arg.Offset,
		arg.Starttime,
		arg.Endtime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesByTagPeriodAreaOrderByScoreRow{}
	for rows.Next() {
		var i GetMoviesByTagPeriodAreaOrderByScoreRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesByTagPeriodAreaOrderByVisitCount = `-- name: GetMoviesByTagPeriodAreaOrderByVisitCount :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       count(*) over () as total
from movie,
     (select distinct movie_id from tags where tags.tag_name like $2) as tags
where period between $5 and $6
  and area like $1
  and id = tags.movie_id
order by visit_count desc
limit $3 offset $4
`

type GetMoviesByTagPeriodAreaOrderByVisitCountParams struct {
	Area      string    `json:"area"`
	TagName   string    `json:"tag_name"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
	Starttime time.Time `json:"starttime"`
	Endtime   time.Time `json:"endtime"`
}

type GetMoviesByTagPeriodAreaOrderByVisitCountRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
	Total     int64     `json:"total"`
}

func (q *Queries) GetMoviesByTagPeriodAreaOrderByVisitCount(ctx context.Context, arg *GetMoviesByTagPeriodAreaOrderByVisitCountParams) ([]*GetMoviesByTagPeriodAreaOrderByVisitCountRow, error) {
	rows, err := q.db.Query(ctx, getMoviesByTagPeriodAreaOrderByVisitCount,
		arg.Area,
		arg.TagName,
		arg.Limit,
		arg.Offset,
		arg.Starttime,
		arg.Endtime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesByTagPeriodAreaOrderByVisitCountRow{}
	for rows.Next() {
		var i GetMoviesByTagPeriodAreaOrderByVisitCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesOrderByBoxOffice = `-- name: GetMoviesOrderByBoxOffice :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       box_office
from movie
order by box_office desc
limit $1
`

type GetMoviesOrderByBoxOfficeRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
	BoxOffice float32   `json:"box_office"`
}

func (q *Queries) GetMoviesOrderByBoxOffice(ctx context.Context, limit int32) ([]*GetMoviesOrderByBoxOfficeRow, error) {
	rows, err := q.db.Query(ctx, getMoviesOrderByBoxOffice, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesOrderByBoxOfficeRow{}
	for rows.Next() {
		var i GetMoviesOrderByBoxOfficeRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.BoxOffice,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesOrderByUserMovieCount = `-- name: GetMoviesOrderByUserMovieCount :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       movieIDs.fallow_count
from movie,
     (select movie_id, count(*) as fallow_count
      from user_movie
      group by movie_id
      order by fallow_count desc
      limit $1) as movieIDs
where movieIDs.movie_id = movie.id
order by fallow_count desc
`

type GetMoviesOrderByUserMovieCountRow struct {
	ID          int64     `json:"id"`
	Actors      []string  `json:"actors"`
	Name        string    `json:"name"`
	AliasName   string    `json:"alias_name"`
	Avatar      string    `json:"avatar"`
	Period      time.Time `json:"period"`
	Score       float32   `json:"score"`
	FallowCount int64     `json:"fallow_count"`
}

func (q *Queries) GetMoviesOrderByUserMovieCount(ctx context.Context, limit int32) ([]*GetMoviesOrderByUserMovieCountRow, error) {
	rows, err := q.db.Query(ctx, getMoviesOrderByUserMovieCount, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesOrderByUserMovieCountRow{}
	for rows.Next() {
		var i GetMoviesOrderByUserMovieCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.FallowCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMoviesOrderByVisitCount = `-- name: GetMoviesOrderByVisitCount :many
select id,
       actors,
       name,
       alias_name,
       avatar,
       period,
       score,
       count(*) over () as total
from movie
order by visit_count desc
limit $1 offset $2
`

type GetMoviesOrderByVisitCountParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetMoviesOrderByVisitCountRow struct {
	ID        int64     `json:"id"`
	Actors    []string  `json:"actors"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Score     float32   `json:"score"`
	Total     int64     `json:"total"`
}

func (q *Queries) GetMoviesOrderByVisitCount(ctx context.Context, arg *GetMoviesOrderByVisitCountParams) ([]*GetMoviesOrderByVisitCountRow, error) {
	rows, err := q.db.Query(ctx, getMoviesOrderByVisitCount, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMoviesOrderByVisitCountRow{}
	for rows.Next() {
		var i GetMoviesOrderByVisitCountRow
		if err := rows.Scan(
			&i.ID,
			&i.Actors,
			&i.Name,
			&i.AliasName,
			&i.Avatar,
			&i.Period,
			&i.Score,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMovie = `-- name: UpdateMovie :one
update movie
set name       = $1,
    alias_name = $2,
    actors     = $3,
    content    = $4,
    avatar     = $5,
    period     = $6,
    area       = $7,
    director   = $8
where id = $9
returning id,name,alias_name,actors,content,avatar,period,area
`

type UpdateMovieParams struct {
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Actors    []string  `json:"actors"`
	Content   string    `json:"content"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Area      string    `json:"area"`
	Director  string    `json:"director"`
	ID        int64     `json:"id"`
}

type UpdateMovieRow struct {
	ID        int64     `json:"id"`
	Name      string    `json:"name"`
	AliasName string    `json:"alias_name"`
	Actors    []string  `json:"actors"`
	Content   string    `json:"content"`
	Avatar    string    `json:"avatar"`
	Period    time.Time `json:"period"`
	Area      string    `json:"area"`
}

func (q *Queries) UpdateMovie(ctx context.Context, arg *UpdateMovieParams) (*UpdateMovieRow, error) {
	row := q.db.QueryRow(ctx, updateMovie,
		arg.Name,
		arg.AliasName,
		arg.Actors,
		arg.Content,
		arg.Avatar,
		arg.Period,
		arg.Area,
		arg.Director,
		arg.ID,
	)
	var i UpdateMovieRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.AliasName,
		&i.Actors,
		&i.Content,
		&i.Avatar,
		&i.Period,
		&i.Area,
	)
	return &i, err
}
