// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: plan.sql

package db

import (
	"context"
	"time"
)

const createPlan = `-- name: CreatePlan :one
insert into plan(movie_id, version, cinema_id, start_at, end_at, price)
VALUES ($1, $2, $3, $4, $5, $6)
returning id
`

type CreatePlanParams struct {
	MovieID  int64     `json:"movie_id"`
	Version  string    `json:"version"`
	CinemaID int64     `json:"cinema_id"`
	StartAt  time.Time `json:"start_at"`
	EndAt    time.Time `json:"end_at"`
	Price    float32   `json:"price"`
}

func (q *Queries) CreatePlan(ctx context.Context, arg *CreatePlanParams) (int64, error) {
	row := q.db.QueryRow(ctx, createPlan,
		arg.MovieID,
		arg.Version,
		arg.CinemaID,
		arg.StartAt,
		arg.EndAt,
		arg.Price,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const deleteOutDatePlans = `-- name: DeleteOutDatePlans :many
delete
from plan
where end_at < now()
returning id
`

func (q *Queries) DeleteOutDatePlans(ctx context.Context) ([]int64, error) {
	rows, err := q.db.Query(ctx, deleteOutDatePlans)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deletePlan = `-- name: DeletePlan :exec
delete
from plan
where id = $1
`

func (q *Queries) DeletePlan(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deletePlan, id)
	return err
}

const existPlansByCinemaID = `-- name: ExistPlansByCinemaID :one
select exists(select 1
              from plan
              where cinema_id = $1
                and plan.end_at > now())
`

func (q *Queries) ExistPlansByCinemaID(ctx context.Context, cinemaID int64) (bool, error) {
	row := q.db.QueryRow(ctx, existPlansByCinemaID, cinemaID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const existPlansByMovieID = `-- name: ExistPlansByMovieID :one
select exists(select 1
              from plan
              where movie_id = $1
                and plan.end_at > now())
`

func (q *Queries) ExistPlansByMovieID(ctx context.Context, movieID int64) (bool, error) {
	row := q.db.QueryRow(ctx, existPlansByMovieID, movieID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getAllPlanIds = `-- name: GetAllPlanIds :many
select id, end_at
from ttms.public.plan
where plan.end_at > now()
`

type GetAllPlanIdsRow struct {
	ID    int64     `json:"id"`
	EndAt time.Time `json:"end_at"`
}

func (q *Queries) GetAllPlanIds(ctx context.Context) ([]*GetAllPlanIdsRow, error) {
	rows, err := q.db.Query(ctx, getAllPlanIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetAllPlanIdsRow{}
	for rows.Next() {
		var i GetAllPlanIdsRow
		if err := rows.Scan(&i.ID, &i.EndAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanByID = `-- name: GetPlanByID :one
select plan.id,
       plan.version,
       movie_id,
       cinema_id,
       cinema.name as cinemaName,
       start_at,
       end_at,
       price
from plan,
     cinema
where plan.id = $1
  and cinema.id = plan.cinema_id
limit 1
`

type GetPlanByIDRow struct {
	ID         int64     `json:"id"`
	Version    string    `json:"version"`
	MovieID    int64     `json:"movie_id"`
	CinemaID   int64     `json:"cinema_id"`
	Cinemaname string    `json:"cinemaname"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
	Price      float32   `json:"price"`
}

func (q *Queries) GetPlanByID(ctx context.Context, id int64) (*GetPlanByIDRow, error) {
	row := q.db.QueryRow(ctx, getPlanByID, id)
	var i GetPlanByIDRow
	err := row.Scan(
		&i.ID,
		&i.Version,
		&i.MovieID,
		&i.CinemaID,
		&i.Cinemaname,
		&i.StartAt,
		&i.EndAt,
		&i.Price,
	)
	return &i, err
}

const getPlans = `-- name: GetPlans :many
select plan.id,
       plan.version,
       movie_id,
       movie.name,
       cinema_id,
       cinema.name      as cinemaName,
       start_at,
       end_at,
       price,
       count(*) over () as total
from plan,
     movie,
     cinema
where plan.movie_id = movie.id
  and plan.cinema_id = cinema.id
  and plan.end_at > now()
order by id desc
limit $1 offset $2
`

type GetPlansParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPlansRow struct {
	ID         int64     `json:"id"`
	Version    string    `json:"version"`
	MovieID    int64     `json:"movie_id"`
	Name       string    `json:"name"`
	CinemaID   int64     `json:"cinema_id"`
	Cinemaname string    `json:"cinemaname"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
	Price      float32   `json:"price"`
	Total      int64     `json:"total"`
}

func (q *Queries) GetPlans(ctx context.Context, arg *GetPlansParams) ([]*GetPlansRow, error) {
	rows, err := q.db.Query(ctx, getPlans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlansRow{}
	for rows.Next() {
		var i GetPlansRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.MovieID,
			&i.Name,
			&i.CinemaID,
			&i.Cinemaname,
			&i.StartAt,
			&i.EndAt,
			&i.Price,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlansByMovie = `-- name: GetPlansByMovie :many
select plan.id,
       plan.version,
       movie_id,
       movie.name,
       cinema_id,
       cinema.name      as cinemaName,
       start_at,
       end_at,
       price,
       count(*) over () as total
from plan,
     movie,
     cinema
where plan.movie_id = $1
  and plan.movie_id = movie.id
  and plan.cinema_id = cinema.id
  and plan.end_at > now()
order by id desc
limit $1 offset $2
`

type GetPlansByMovieParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetPlansByMovieRow struct {
	ID         int64     `json:"id"`
	Version    string    `json:"version"`
	MovieID    int64     `json:"movie_id"`
	Name       string    `json:"name"`
	CinemaID   int64     `json:"cinema_id"`
	Cinemaname string    `json:"cinemaname"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
	Price      float32   `json:"price"`
	Total      int64     `json:"total"`
}

func (q *Queries) GetPlansByMovie(ctx context.Context, arg *GetPlansByMovieParams) ([]*GetPlansByMovieRow, error) {
	rows, err := q.db.Query(ctx, getPlansByMovie, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlansByMovieRow{}
	for rows.Next() {
		var i GetPlansByMovieRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.MovieID,
			&i.Name,
			&i.CinemaID,
			&i.Cinemaname,
			&i.StartAt,
			&i.EndAt,
			&i.Price,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlansByMovieAndStartTimeOrderByPrice = `-- name: GetPlansByMovieAndStartTimeOrderByPrice :many
select plan.id,
       plan.version,
       movie_id,
       cinema_id,
       cinema.name      as cinemaName,
       start_at,
       end_at,
       price,
       count(*) over () as total
from plan,
     cinema
where movie_id = $1
  and cinema.id = plan.cinema_id
  and start_at between $4 and $5
  and plan.end_at > now()
order by price
limit $2 offset $3
`

type GetPlansByMovieAndStartTimeOrderByPriceParams struct {
	MovieID   int64     `json:"movie_id"`
	Limit     int32     `json:"limit"`
	Offset    int32     `json:"offset"`
	Starttime time.Time `json:"starttime"`
	Endtime   time.Time `json:"endtime"`
}

type GetPlansByMovieAndStartTimeOrderByPriceRow struct {
	ID         int64     `json:"id"`
	Version    string    `json:"version"`
	MovieID    int64     `json:"movie_id"`
	CinemaID   int64     `json:"cinema_id"`
	Cinemaname string    `json:"cinemaname"`
	StartAt    time.Time `json:"start_at"`
	EndAt      time.Time `json:"end_at"`
	Price      float32   `json:"price"`
	Total      int64     `json:"total"`
}

func (q *Queries) GetPlansByMovieAndStartTimeOrderByPrice(ctx context.Context, arg *GetPlansByMovieAndStartTimeOrderByPriceParams) ([]*GetPlansByMovieAndStartTimeOrderByPriceRow, error) {
	rows, err := q.db.Query(ctx, getPlansByMovieAndStartTimeOrderByPrice,
		arg.MovieID,
		arg.Limit,
		arg.Offset,
		arg.Starttime,
		arg.Endtime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetPlansByMovieAndStartTimeOrderByPriceRow{}
	for rows.Next() {
		var i GetPlansByMovieAndStartTimeOrderByPriceRow
		if err := rows.Scan(
			&i.ID,
			&i.Version,
			&i.MovieID,
			&i.CinemaID,
			&i.Cinemaname,
			&i.StartAt,
			&i.EndAt,
			&i.Price,
			&i.Total,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlansCountByTimeWithLock = `-- name: GetPlansCountByTimeWithLock :one
select exists(select 1
              from plan pl
              where pl.cinema_id = $3
                and (pl.start_at <= $1
                         and pl.end_at >= $2
                  or pl.start_at >= $1
                         and pl.end_at <= $2
                  or pl.start_at between $1 and $2
                  or pl.end_at between $1 and $2)
                  for update
           )
`

type GetPlansCountByTimeWithLockParams struct {
	StartAt  time.Time `json:"start_at"`
	EndAt    time.Time `json:"end_at"`
	CinemaID int64     `json:"cinema_id"`
}

func (q *Queries) GetPlansCountByTimeWithLock(ctx context.Context, arg *GetPlansCountByTimeWithLockParams) (bool, error) {
	row := q.db.QueryRow(ctx, getPlansCountByTimeWithLock, arg.StartAt, arg.EndAt, arg.CinemaID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}
